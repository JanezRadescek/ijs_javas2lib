\documentclass[english]{article}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{amsmath}

\begin{document}

\section{Overview}

This article provides some information about \textit{Cli} alongside with examples on how to use it.

\section{Introduction}

Cli giveus us acces to \textit{pipes} which can manipulate and work with S2 format. Pipes works as followed. They get valid S2 format. They do something with it. Finally they send changed but still valid S2 format to the next Pipe in line. We get desired pipeline by combaning appropriate pipes.
The main purpose of Cli is to parse input arguments and based on them, it build pipeline from pipes. In its curent version every pipe can be included at most ones and in predetermed unmutable order. In most cases the order of pipes doesnt matter. In thoes that does the corect order can be achieved by reapingly calling Cli, thought for some task it may be more efficent to build a program that can directly use pipes.

In next section we will briefly explain parsing and how Cli build pipes together.
In the section to follow we will explain options and functionalities of coresponding pipe along side with examples of posible arguments. The implementation of pipes will not be discused here.
In the last section there will be some more realistic working examples and some examples that doesnt work. 

\section{Parsing}
For every funcionality that we want to include into our pipeline we must include apropriate pipe. We do so by passing flag (one that represent desired pipe) to the Cli followed by arguments if any is needed. Functionality, pipe, flag and arguments together are called \textit{Option}. Order of flags doesnt matter. It is inportant thought that if option has any arguments, this arguments are directly after flag and in corect order. 

If there is problem with the input arguments (flags + arguments) or file acces, Cli will stop with a brif explanation why.

Cli stats by parsing input arguments.
After Cli parses flags and their argumentsit it starts including pipes coresponding to flags. Eventhoug all the pipes are complitly mutualy compatible, Cli will look only for pipes that needs input when input is given and vice versa. It isnt mandatory to include output callback, thought without it all the work will be in vain. At the end it runs the pipeline, writes any posible errors that ocured during execution of Cli and in the if everything was successful it will print \textbf{CLI finished}.
Warning: From point of Cli none existing or pointless pipeline is perfectly fine.



\section{Options}
The structure of following subsections will be:
\begin{itemize}
\item functionalities of the option
\item requirements if any
\item{
Flag and arguments in the following structure:
 \begin{itemize}
 \item[$\bullet$] -flag
 \item[$\circ$] mandatory argument 1
 \item[$\circ$] mandatory argument 2
 
 ...
  \item[$\circ$] mandatory argument n
  \item[\textasteriskcentered] optional argument
 \end{itemize}
 }
\item example.
\end{itemize}

As we mentioned before Cli builds pipes in predetermined order therefore we will list options in the same order as their pipes (if they represent one) will be in pipeline.

\subsection{Help}
Option help doesnt actualy corespond to any pipe. It prints basic info on how to use Cli. Any aditional options are discarded.
\begin{itemize}
\item[$\bullet$] -h
\end{itemize}
Print help : \begin{lstlisting} 
-h
\end{lstlisting}


\subsection{Input}
Option input also doesnt corespond to any pipe. Its purpuse is to read lines from S2 file saved on disk and give them to the next pipe in line. Directories must be valid. It has optional secondary directory.
\begin{itemize}
\item[$\bullet$] -i
\item[$\circ$] primary directory
\item[\textasteriskcentered] secondary directory
\end{itemize}
Read file1.s2 from disk : \begin{lstlisting} 
-i ./directory1/directory2/file1.s2
\end{lstlisting}


\subsection{Merge}
Option merge merges two S2 files into one S2 file. 

It needs option input with primary and secondary directory.
\begin{itemize}
 \item[$\bullet$] -m
 \end{itemize}
merge two files provided in option input : \begin{lstlisting} 
-m
\end{lstlisting}


\subsection{Data}
This option filters lines. If we want to discard all coments there must be 0 in argument on 1st place from right to left. If we want to discard all special messagas there must be 0 in argument on 2nd place from right to left. If we want to discard all meta data there must be 0 in argument on 3rd place from right to left. If we want to discard all packets there must be 0 in argument on 4th place from right to left. Warning in curent version of Data filtering we do not allow discarding meta data. 

\noindent Requirements : 
\begin{itemize}
\item option input. 
\end{itemize}
Flag and arguments :
\begin{itemize}
\item[$\bullet$] -fd
\item[$\circ$] data
\end{itemize}
Discard comments and packets : 
\begin{lstlisting} 
-fd 0110
\end{lstlisting}


\subsection{Comments}
This option filters coments based on the regex provided in argument.

\noindent Requirements : 
\begin{itemize}
\item option input. 
\end{itemize}
Flag and arguments : 

\begin{itemize}
\item[$\bullet$] -fc
\item[$\circ$] regex
\end{itemize}
Keep only comments containing word Hello : 
\begin{lstlisting} 
-fc (.*s|)Hello(s.*|)
\end{lstlisting}


\subsection{Special messages}
This option filters special message. It keeps messagas that have same who and what as in arguments and suits regex.  

\noindent Requirements : 
\begin{itemize}
\item option input. 
\end{itemize}
Flag and arguments :
\begin{itemize}
\item[$\bullet$] -fs
\item[$\circ$] who
\item[$\circ$] what
\item[$\circ$] regex
\end{itemize}
Keep only messages from T about U containing word Hello : 
\begin{lstlisting} 
-fs T U (.*s|)Hello(s.*|)
\end{lstlisting}


\subsection{Handles}
This option filters packages based on handles. To include handle \#i, put 1 in position i+1 (from right to left) in the argument, to exclude it, put 0. 

\noindent Requirements : 
\begin{itemize}
\item option input. 
\end{itemize}
Flag and arguments :
\begin{itemize}
\item[$\bullet$] -fh
\item[$\circ$] handles
\end{itemize}
Keep only packages with handle 0,1 and 4 : 
\begin{lstlisting} 
-fh 10011
\end{lstlisting}


\subsection{Filter time}
This option filters lines with time. We keep only lines inside time interval. Start is included, end is exclusive. If 3rd optional argument is true we give comments and special messagas last known time and filter them accordingly. 

\noindent Requirements : 
\begin{itemize}
\item option input OR option generate
\end{itemize}
Flag and arguments :
\begin{itemize}
\item[$\bullet$] -ft
\item[$\circ$] start [s]
\item[$\circ$] time [s]
\item[\textasteriskcentered] aproximate
\end{itemize}
Keep only lines from 5th second till 15th second : 
\begin{lstlisting} 
-ft 5 15 true
\end{lstlisting}


\subsection{Change time}
This option changes timespams by adding them argument. If argument is too negative (firt line with time would have negative timestamp) it changes it so the first line wth time will have timestamp 0. 

\noindent Requirements : 
\begin{itemize}
\item option input. 
\end{itemize}
Flag and arguments :
\begin{itemize}
\item[$\bullet$] -ct
\item[$\circ$] delay [ns]
\end{itemize}
add timestamps 2s : 
\begin{lstlisting} 
-ct 2E9
\end{lstlisting}


\subsection{Change datetime}
This option changes date and time in meta data. We can only change date time backwards. This option also changes timestamps so the absolute time doesnt change. Argument must be date, time and timezone in ISO format. 

\noindent Requirements : 
\begin{itemize}
\item option input. 
\end{itemize}
Flag and arguments :
\begin{itemize}
\item[$\bullet$] -cdt
\item[$\circ$] dateTimeZone
\end{itemize}
change date time : 
\begin{lstlisting} 
-cdt 2018-01-31T10:30:10.554+0100
\end{lstlisting}


\subsection{Process time}
This option localy changes time with least squares method. 

\noindent Requirements : 
\begin{itemize}
\item option input. 
\end{itemize}
Flag and arguments :
\begin{itemize}
\item[$\bullet$] -p
\end{itemize}
process time : 
\begin{lstlisting} 
-p
\end{lstlisting}


\subsection{Statistics}
Produces basic statistics about S2 file and saves it into file provided in argument. If argument is omitted statistics will be printed to standard output insted.

\noindent Requirements : 
\begin{itemize}
\item option input. 
\end{itemize}
Flag and arguments :
\begin{itemize}
\item[$\bullet$] -s
\item[\textasteriskcentered] directory
\end{itemize}
print statistics : 
\begin{lstlisting} 
-s
\end{lstlisting}


\subsection{Output}
This option saves results of previous pipes. Based on extension of file provided in argument it will save in either txt,csv or S2 format. If we provide only extension it will print result on standard output in coresponding format. Warning : if the directory doesnt exist, it will create one.

\noindent Requirements : 
\begin{itemize}
\item option input OR option generate. 
\end{itemize}
Flag and arguments :
\begin{itemize}
\item[$\bullet$] -o
\item[$\circ$] directory
\end{itemize}
save result in csv format : 
\begin{lstlisting} 
-o ./directory/file.csv
\end{lstlisting}


\subsection{Generate random}
This option simulates procces of generating samples on device and sending them over wifi to android. It makes new S2 file in PCARD standard. In order to make it more realistics it is made pseudo-randomly within boundaries provided with arguments. It will generate file in time interval provided with option filter time and then save it to output provided with option output. In order to reapet random result we provide seed for random generator. Frequency is expected frequency of device this this program tries to simulate (must be a positive value). Frequency change is faktor of how much can frequency change during simulation. Pecenting missing is aproximate faktor of packets that should be lost. Normal delay is maximum value of delay that occuers for every packet. Big dela chance is chance that packets are significantly delayed than they all come in quick burst. Big delay is maximum value for big delay. Big delay canot happen again till previous big delay has ended. Disconects are scattered randomly across whole S2 file. They can overlap or be so small that they dont cover any package at all! When disconect ocurs device `stops` recoding, resets counters and add comment \''Disconect\'' . Consequently android doesnt get any packets. If we want file without `wifi-flaves` we set percentage missing, normal delay and big delay chance to zero. 

\noindent Requirements : 
\begin{itemize}
\item option output
\item option filter time
\end{itemize}
Flag and arguments :

\begin{itemize}
\item[$\bullet$] -g2
\item[$\circ$] seed for random [long]
\item[$\circ$] frequency in Hz [float] (around 128 for PCARD)
\item[$\circ$] frequency change [0..1]
\item[$\circ$] percentage missing [0..1]
\item[$\circ$] normal delay in s [double]
\item[$\circ$] big delay chance [0..1]
\item[$\circ$] big delay in s [double]
\item[$\circ$] number of disconects

\end{itemize}
generate S2 file : 
\begin{lstlisting} 
-g 1 128 0.1 0.2 0.001 0.01 0.1 3 -o ./directory/file.s2 -t 5 18
\end{lstlisting}


\section{Examples}

In the following examples we will assume we have 2 folders \textit{folderIn} and \textit{folderOut} in curent directory. In folder \textit{folderIn} we have 2 files called \textit{file1.s2} and \textit{file2.s2} and no others. \textit{folderOut} is empty.

\subsection{Working}
Here we will provide some working examples that can be copied and used. 

Lets say we forgot what is in file \textit{file1.s2}. We want some basic info to help us remember. Later we wont need it therefore we dont save it. Call Cli as followed:
$$\text{Cli -i ./folderIn/file1.s2 -s}$$
We realize this isnt file we wanted. We quickly look into second file. As we mentioned before the order in which options appear doesnt matter.
$$\text{Cli -s -i ./folderIn/file2.s2}$$
This is the one. We are actualy only interested in packets from \textbf{30s} till \textbf{125s}. We want the result saved in \textit{folderOut} in new file caled \textit{file3.s2}.
$$\text{Cli -i ./folderIn/file2.s2 -ft 30 125 -fd 1100 -o ./folderOut/file3.s2}$$
we are not interested in all the comment and special messages in this time interval, therefore we only keep comments which include word \textbf{time} and \textbf{warnings} from \textbf{recording device} that begin with \textbf{t1}. We want it in txt format so we can read it directly.
$$\text{Cli -fc .*time.* -fs 1 w t1.* -i ./folderOut/file3.s2 -o ./folderOut/file4.txt}$$

%For testing purposes we want to generate file 

Our first coworker asked us to get him data from \textit{file1.s2} on \textbf{handle=2} in \textbf{csv} format.
$$\text{Cli -i ./folderIn/file1.s2  -fh 100 -o ./folderOut/coworker1.csv}$$
After some work he realizes the timestaps are not as expected and asks us to fix them as much as possible. We override previous file.
$$\text{Cli -p -i ./folderIn/file1.s2 -fh 100 -o ./folderOut/coworker1.csv}$$
Our second coworker asked us to get him data from \textit{file1.s2} and \textit{file2.s2} in \textbf{one file}.
$$\text{Cli -m -i ./folderIn/file2.s2 ./folderIn/file1.s2 -o ./folderOut/coworker2.s2}$$
Our second coworker realizes that times are delayed for \textbf{0.001s} and dateTime in metadata should be \textbf{25.2.2017 15h 31min UTC} and asks us to fix it.
$$\text{Cli -ct -1000000 -cdt 2017-02-25T15:31:00.000+0000}$$ $$ \text{-i ./folderOut/coworker2.s2 -o ./folderOut/coworker2fixed.s2}$$



\subsection{Misconceptions}
Here we will provide some examples that doesnt work or not as expected.

One might expect that the next command line will save statistics into file123.txt. What will actually happes is statistics will get printed on stdout and S2 file itself will be saved in txt format.
$$\text{Cli -s -i ./folderIn/file1.s2 -o ./folderOut/file123.txt}$$

The next command line is valid but useless since it dosnt save the work done.
$$\text{Cli -i ./folderIn/file1.s2 -ft 10 20}$$

The next command line is invalid since option output requires directory.
$$\text{Cli -i ./folderIn/file1.s2 -ft 10 20 true -o}$$

The next command line will ignore option generate because we provided input. Therefore the next 2 commans lines has the same functionality.
$$\text{Cli -i ./folderIn/file1.s2 -g 1 128 0.1 0.2 0.001 0.01 0.1 3 -o ./directory/file.s2 -t 5 18}$$
$$\text{Cli -i ./folderIn/file1.s2 -o ./directory/file.s2 -t 5 18}$$

The next command line will ignore option change time because we didnt provided input. Therefore the next 2 commans lines has the same functionality.
$$\text{Cli -g 1 128 0.1 0.2 0.001 0.01 0.1 3 -o ./directory/file.s2 -t 5 18}$$
$$\text{Cli -g 1 128 0.1 0.2 0.001 0.01 0.1 3 -o ./directory/file.s2 -t 5 18 - ct 1000}$$

The next command line will ignore all options except help. Therefore the next 2 commans lines has the same functionality.
$$\text{Cli -h -i ./folderIn/file1.s2 -o ./directory/file.s2 -t 5 18}$$
$$\text{Cli -h}$$





%\section{Examples}
%
%In all examples to follow we will assume we have two \textbf{S2} files named \textbf{file1.s2} and \textbf{file2.s2} both stored in \textbf{./files/} . Examples are independent.
%
%
%\subsection{example}
%Lets say file1.s2 stores data about EKG measurement and we want to know how long did it last. For that we call Cli as follows. $$\textbf{Cli -s -i ./files/file1.s2} $$
% \textbf{-i} is always necessary and has mandatory arguments file directory. After running the program we will get statistics of \textbf{file1.s2} on standard output.
%
%Now we want to know the actual data for the first 30s. We want them saved in file \textbf{output1.csv} for later use: $$ \textbf{Cli -r -i ./files/file1.s2 -o ./files/output1.csv -t 0 30} $$
%Flag \textbf{-r} tels the program we want actual data in CSV format, \textbf{-o} has necessary argument directory of file in which we will save our CSV data. There is also \textbf{-t} with 2 arguments which represent time interval.
%
%
%\subsection{example}
%First we want statistics for both files. $$\textbf{Cli -s -i ./files/file1.s2} $$ $$\textbf{Cli -s -i ./files/file2.s2} $$
%Lets say the measurement on \textbf{file2.s2} is too long. We have decided we only want part of data between 45s and 75s since the beginning. We also don't want to keep special messages.We call Cli as follows.
%$$ \textbf{Cli -c -i ./files/file2.s2 -o ./files/newFile2.s2 -t 45 75 -d 101}$$
%Now we want data from \textbf{file1.s2} and \textbf{newFile2.s2} to be in the same S2 file named \textbf{merged.s2}, but in the way we will latter be able to distinguish from which file data came.
%$$ \textbf{Cli -m false -i ./files/file1.s2 ./files/newFile2.s2 -o ./files/merged.s2}$$
%Let say \textbf{file1.s2} has data on two handles, 0 and 1 and \textbf{file2.s2} has data on three handles, 0, 1, 31. Data from first input file will keep their original Handles(0 and 1 in this case). For the second file it will calculate new handles. WARNING mapping depends on sequence in which struct definitions are written. 0 was already used in the first file therefore it will try to give it 1(0+1). 1 was also already used therefore it will try to give it 2(0+2). This was no used before therefore in handle 0 from second file will be handle 2 in merged file. We do the same for handle 1. 1 was used in the first file. 2 was used for 0 from second file. 3 was not used before therefore 1 will be given 3 in next file. Notice that if it would calculate new handle for 1 before 0 it would result in 1->2 0->3.Since 31 was not used before it will stay the same in merged file.
%
%
%\subsection{example}
%Let say we have 2 mesurments saved on \textbf{file1.s2}. We are particularly interested in data between 25-30 seconds and 130-205 seconds in first mesurement. First we cut each part out and save it. 
%$$ \textbf{Cli -c -i ./files/file1.s2 -o ./files/cut1.s2 -t 25 30 -h 0}    $$
%$$ \textbf{Cli -c -i ./files/file1.s2 -o ./files cut2.s2 -t 130 205 -h 0}$$
%Now we merge them back into new file. Since they have data from same initial measurement we want them to look like it.
%$$ \textbf{Cli -m true -i ./files/cut1.s2 ./files/cut2.s2 -o ./files/merged.s2}$$


\end{document}